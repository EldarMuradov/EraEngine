// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: NvBlastExtLlSerialization.capn
#pragma once

#ifndef CAPNP_INCLUDED_9a4a58fac38375e0_
#define CAPNP_INCLUDED_9a4a58fac38375e0_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 6001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
    namespace schemas {

        CAPNP_DECLARE_SCHEMA(ce4f8468c36f427d);
        CAPNP_DECLARE_SCHEMA(d5e1a9fb31b1350d);
        CAPNP_DECLARE_SCHEMA(b292bd608606f041);
        enum class Type_b292bd608606f041 : uint16_t {
            ASSET_DATA_BLOCK,
            INSTANCE_DATA_BLOCK,
        };
        CAPNP_DECLARE_ENUM(Type, b292bd608606f041);
        CAPNP_DECLARE_SCHEMA(92818c664a7b1aba);
        CAPNP_DECLARE_SCHEMA(c43da43c95eada67);
        CAPNP_DECLARE_SCHEMA(f018cbfcaacb3a55);
        CAPNP_DECLARE_SCHEMA(bfd00835cc19bf3a);

    }  // namespace schemas
}  // namespace capnp

namespace Nv {
    namespace Blast {
        namespace Serialization {

            struct Asset {
                Asset() = delete;

                class Reader;
                class Builder;
                class Pipeline;

                struct _capnpPrivate {
                    CAPNP_DECLARE_STRUCT_HEADER(ce4f8468c36f427d, 2, 7)
#if !CAPNP_LITE
                        static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
                };
            };

            struct NvBlastDataBlock {
                NvBlastDataBlock() = delete;

                class Reader;
                class Builder;
                class Pipeline;
                typedef ::capnp::schemas::Type_b292bd608606f041 Type;


                struct _capnpPrivate {
                    CAPNP_DECLARE_STRUCT_HEADER(d5e1a9fb31b1350d, 2, 0)
#if !CAPNP_LITE
                        static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
                };
            };

            struct NvBlastChunk {
                NvBlastChunk() = delete;

                class Reader;
                class Builder;
                class Pipeline;

                struct _capnpPrivate {
                    CAPNP_DECLARE_STRUCT_HEADER(92818c664a7b1aba, 3, 1)
#if !CAPNP_LITE
                        static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
                };
            };

            struct NvBlastBond {
                NvBlastBond() = delete;

                class Reader;
                class Builder;
                class Pipeline;

                struct _capnpPrivate {
                    CAPNP_DECLARE_STRUCT_HEADER(c43da43c95eada67, 1, 2)
#if !CAPNP_LITE
                        static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
                };
            };

            struct NvBlastSupportGraph {
                NvBlastSupportGraph() = delete;

                class Reader;
                class Builder;
                class Pipeline;

                struct _capnpPrivate {
                    CAPNP_DECLARE_STRUCT_HEADER(f018cbfcaacb3a55, 1, 4)
#if !CAPNP_LITE
                        static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
                };
            };

            struct UUID {
                UUID() = delete;

                class Reader;
                class Builder;
                class Pipeline;

                struct _capnpPrivate {
                    CAPNP_DECLARE_STRUCT_HEADER(bfd00835cc19bf3a, 0, 1)
#if !CAPNP_LITE
                        static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
                };
            };

            // =======================================================================================

            class Asset::Reader {
            public:
                typedef Asset Reads;

                Reader() = default;
                inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

                inline ::capnp::MessageSize totalSize() const {
                    return _reader.totalSize().asPublic();
                }

#if !CAPNP_LITE
                inline ::kj::StringTree toString() const {
                    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
                }
#endif  // !CAPNP_LITE

                inline bool hasHeader() const;
                inline  ::Nv::Blast::Serialization::NvBlastDataBlock::Reader getHeader() const;

                inline bool hasID() const;
                inline  ::Nv::Blast::Serialization::UUID::Reader getID() const;

                inline  ::uint32_t getChunkCount() const;

                inline bool hasGraph() const;
                inline  ::Nv::Blast::Serialization::NvBlastSupportGraph::Reader getGraph() const;

                inline  ::uint32_t getLeafChunkCount() const;

                inline  ::uint32_t getFirstSubsupportChunkIndex() const;

                inline  ::uint32_t getBondCount() const;

                inline bool hasChunks() const;
                inline  ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>::Reader getChunks() const;

                inline bool hasBonds() const;
                inline  ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>::Reader getBonds() const;

                inline bool hasSubtreeLeafChunkCounts() const;
                inline  ::capnp::List< ::uint32_t>::Reader getSubtreeLeafChunkCounts() const;

                inline bool hasChunkToGraphNodeMap() const;
                inline  ::capnp::List< ::uint32_t>::Reader getChunkToGraphNodeMap() const;

            private:
                ::capnp::_::StructReader _reader;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::_::PointerHelpers;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::List;
                friend class ::capnp::MessageBuilder;
                friend class ::capnp::Orphanage;
            };

            class Asset::Builder {
            public:
                typedef Asset Builds;

                Builder() = delete;  // Deleted to discourage incorrect usage.
                // You can explicitly initialize to nullptr instead.
                inline Builder(decltype(nullptr)) {}
                inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
                inline operator Reader() const { return Reader(_builder.asReader()); }
                inline Reader asReader() const { return *this; }

                inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
                inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

                inline bool hasHeader();
                inline  ::Nv::Blast::Serialization::NvBlastDataBlock::Builder getHeader();
                inline void setHeader(::Nv::Blast::Serialization::NvBlastDataBlock::Reader value);
                inline  ::Nv::Blast::Serialization::NvBlastDataBlock::Builder initHeader();
                inline void adoptHeader(::capnp::Orphan< ::Nv::Blast::Serialization::NvBlastDataBlock>&& value);
                inline ::capnp::Orphan< ::Nv::Blast::Serialization::NvBlastDataBlock> disownHeader();

                inline bool hasID();
                inline  ::Nv::Blast::Serialization::UUID::Builder getID();
                inline void setID(::Nv::Blast::Serialization::UUID::Reader value);
                inline  ::Nv::Blast::Serialization::UUID::Builder initID();
                inline void adoptID(::capnp::Orphan< ::Nv::Blast::Serialization::UUID>&& value);
                inline ::capnp::Orphan< ::Nv::Blast::Serialization::UUID> disownID();

                inline  ::uint32_t getChunkCount();
                inline void setChunkCount(::uint32_t value);

                inline bool hasGraph();
                inline  ::Nv::Blast::Serialization::NvBlastSupportGraph::Builder getGraph();
                inline void setGraph(::Nv::Blast::Serialization::NvBlastSupportGraph::Reader value);
                inline  ::Nv::Blast::Serialization::NvBlastSupportGraph::Builder initGraph();
                inline void adoptGraph(::capnp::Orphan< ::Nv::Blast::Serialization::NvBlastSupportGraph>&& value);
                inline ::capnp::Orphan< ::Nv::Blast::Serialization::NvBlastSupportGraph> disownGraph();

                inline  ::uint32_t getLeafChunkCount();
                inline void setLeafChunkCount(::uint32_t value);

                inline  ::uint32_t getFirstSubsupportChunkIndex();
                inline void setFirstSubsupportChunkIndex(::uint32_t value);

                inline  ::uint32_t getBondCount();
                inline void setBondCount(::uint32_t value);

                inline bool hasChunks();
                inline  ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>::Builder getChunks();
                inline void setChunks(::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>::Reader value);
                inline  ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>::Builder initChunks(unsigned int size);
                inline void adoptChunks(::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>>&& value);
                inline ::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>> disownChunks();

                inline bool hasBonds();
                inline  ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>::Builder getBonds();
                inline void setBonds(::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>::Reader value);
                inline  ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>::Builder initBonds(unsigned int size);
                inline void adoptBonds(::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>>&& value);
                inline ::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>> disownBonds();

                inline bool hasSubtreeLeafChunkCounts();
                inline  ::capnp::List< ::uint32_t>::Builder getSubtreeLeafChunkCounts();
                inline void setSubtreeLeafChunkCounts(::capnp::List< ::uint32_t>::Reader value);
                inline void setSubtreeLeafChunkCounts(::kj::ArrayPtr<const  ::uint32_t> value);
                inline  ::capnp::List< ::uint32_t>::Builder initSubtreeLeafChunkCounts(unsigned int size);
                inline void adoptSubtreeLeafChunkCounts(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
                inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownSubtreeLeafChunkCounts();

                inline bool hasChunkToGraphNodeMap();
                inline  ::capnp::List< ::uint32_t>::Builder getChunkToGraphNodeMap();
                inline void setChunkToGraphNodeMap(::capnp::List< ::uint32_t>::Reader value);
                inline void setChunkToGraphNodeMap(::kj::ArrayPtr<const  ::uint32_t> value);
                inline  ::capnp::List< ::uint32_t>::Builder initChunkToGraphNodeMap(unsigned int size);
                inline void adoptChunkToGraphNodeMap(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
                inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownChunkToGraphNodeMap();

            private:
                ::capnp::_::StructBuilder _builder;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
                friend class ::capnp::Orphanage;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::_::PointerHelpers;
            };

#if !CAPNP_LITE
            class Asset::Pipeline {
            public:
                typedef Asset Pipelines;

                inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
                inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
                    : _typeless(kj::mv(typeless)) {}

                inline  ::Nv::Blast::Serialization::NvBlastDataBlock::Pipeline getHeader();
                inline  ::Nv::Blast::Serialization::UUID::Pipeline getID();
                inline  ::Nv::Blast::Serialization::NvBlastSupportGraph::Pipeline getGraph();
            private:
                ::capnp::AnyPointer::Pipeline _typeless;
                friend class ::capnp::PipelineHook;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
            };
#endif  // !CAPNP_LITE

            class NvBlastDataBlock::Reader {
            public:
                typedef NvBlastDataBlock Reads;

                Reader() = default;
                inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

                inline ::capnp::MessageSize totalSize() const {
                    return _reader.totalSize().asPublic();
                }

#if !CAPNP_LITE
                inline ::kj::StringTree toString() const {
                    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
                }
#endif  // !CAPNP_LITE

                inline  ::Nv::Blast::Serialization::NvBlastDataBlock::Type getDataType() const;

                inline  ::uint32_t getFormatVersion() const;

                inline  ::uint32_t getSize() const;

            private:
                ::capnp::_::StructReader _reader;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::_::PointerHelpers;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::List;
                friend class ::capnp::MessageBuilder;
                friend class ::capnp::Orphanage;
            };

            class NvBlastDataBlock::Builder {
            public:
                typedef NvBlastDataBlock Builds;

                Builder() = delete;  // Deleted to discourage incorrect usage.
                // You can explicitly initialize to nullptr instead.
                inline Builder(decltype(nullptr)) {}
                inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
                inline operator Reader() const { return Reader(_builder.asReader()); }
                inline Reader asReader() const { return *this; }

                inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
                inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

                inline  ::Nv::Blast::Serialization::NvBlastDataBlock::Type getDataType();
                inline void setDataType(::Nv::Blast::Serialization::NvBlastDataBlock::Type value);

                inline  ::uint32_t getFormatVersion();
                inline void setFormatVersion(::uint32_t value);

                inline  ::uint32_t getSize();
                inline void setSize(::uint32_t value);

            private:
                ::capnp::_::StructBuilder _builder;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
                friend class ::capnp::Orphanage;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::_::PointerHelpers;
            };

#if !CAPNP_LITE
            class NvBlastDataBlock::Pipeline {
            public:
                typedef NvBlastDataBlock Pipelines;

                inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
                inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
                    : _typeless(kj::mv(typeless)) {}

            private:
                ::capnp::AnyPointer::Pipeline _typeless;
                friend class ::capnp::PipelineHook;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
            };
#endif  // !CAPNP_LITE

            class NvBlastChunk::Reader {
            public:
                typedef NvBlastChunk Reads;

                Reader() = default;
                inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

                inline ::capnp::MessageSize totalSize() const {
                    return _reader.totalSize().asPublic();
                }

#if !CAPNP_LITE
                inline ::kj::StringTree toString() const {
                    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
                }
#endif  // !CAPNP_LITE

                inline bool hasCentroid() const;
                inline  ::capnp::List<float>::Reader getCentroid() const;

                inline float getVolume() const;

                inline  ::uint32_t getParentChunkIndex() const;

                inline  ::uint32_t getFirstChildIndex() const;

                inline  ::uint32_t getChildIndexStop() const;

                inline  ::uint32_t getUserData() const;

            private:
                ::capnp::_::StructReader _reader;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::_::PointerHelpers;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::List;
                friend class ::capnp::MessageBuilder;
                friend class ::capnp::Orphanage;
            };

            class NvBlastChunk::Builder {
            public:
                typedef NvBlastChunk Builds;

                Builder() = delete;  // Deleted to discourage incorrect usage.
                // You can explicitly initialize to nullptr instead.
                inline Builder(decltype(nullptr)) {}
                inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
                inline operator Reader() const { return Reader(_builder.asReader()); }
                inline Reader asReader() const { return *this; }

                inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
                inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

                inline bool hasCentroid();
                inline  ::capnp::List<float>::Builder getCentroid();
                inline void setCentroid(::capnp::List<float>::Reader value);
                inline void setCentroid(::kj::ArrayPtr<const float> value);
                inline  ::capnp::List<float>::Builder initCentroid(unsigned int size);
                inline void adoptCentroid(::capnp::Orphan< ::capnp::List<float>>&& value);
                inline ::capnp::Orphan< ::capnp::List<float>> disownCentroid();

                inline float getVolume();
                inline void setVolume(float value);

                inline  ::uint32_t getParentChunkIndex();
                inline void setParentChunkIndex(::uint32_t value);

                inline  ::uint32_t getFirstChildIndex();
                inline void setFirstChildIndex(::uint32_t value);

                inline  ::uint32_t getChildIndexStop();
                inline void setChildIndexStop(::uint32_t value);

                inline  ::uint32_t getUserData();
                inline void setUserData(::uint32_t value);

            private:
                ::capnp::_::StructBuilder _builder;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
                friend class ::capnp::Orphanage;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::_::PointerHelpers;
            };

#if !CAPNP_LITE
            class NvBlastChunk::Pipeline {
            public:
                typedef NvBlastChunk Pipelines;

                inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
                inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
                    : _typeless(kj::mv(typeless)) {}

            private:
                ::capnp::AnyPointer::Pipeline _typeless;
                friend class ::capnp::PipelineHook;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
            };
#endif  // !CAPNP_LITE

            class NvBlastBond::Reader {
            public:
                typedef NvBlastBond Reads;

                Reader() = default;
                inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

                inline ::capnp::MessageSize totalSize() const {
                    return _reader.totalSize().asPublic();
                }

#if !CAPNP_LITE
                inline ::kj::StringTree toString() const {
                    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
                }
#endif  // !CAPNP_LITE

                inline bool hasNormal() const;
                inline  ::capnp::List<float>::Reader getNormal() const;

                inline float getArea() const;

                inline bool hasCentroid() const;
                inline  ::capnp::List<float>::Reader getCentroid() const;

                inline  ::uint32_t getUserData() const;

            private:
                ::capnp::_::StructReader _reader;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::_::PointerHelpers;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::List;
                friend class ::capnp::MessageBuilder;
                friend class ::capnp::Orphanage;
            };

            class NvBlastBond::Builder {
            public:
                typedef NvBlastBond Builds;

                Builder() = delete;  // Deleted to discourage incorrect usage.
                // You can explicitly initialize to nullptr instead.
                inline Builder(decltype(nullptr)) {}
                inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
                inline operator Reader() const { return Reader(_builder.asReader()); }
                inline Reader asReader() const { return *this; }

                inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
                inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

                inline bool hasNormal();
                inline  ::capnp::List<float>::Builder getNormal();
                inline void setNormal(::capnp::List<float>::Reader value);
                inline void setNormal(::kj::ArrayPtr<const float> value);
                inline  ::capnp::List<float>::Builder initNormal(unsigned int size);
                inline void adoptNormal(::capnp::Orphan< ::capnp::List<float>>&& value);
                inline ::capnp::Orphan< ::capnp::List<float>> disownNormal();

                inline float getArea();
                inline void setArea(float value);

                inline bool hasCentroid();
                inline  ::capnp::List<float>::Builder getCentroid();
                inline void setCentroid(::capnp::List<float>::Reader value);
                inline void setCentroid(::kj::ArrayPtr<const float> value);
                inline  ::capnp::List<float>::Builder initCentroid(unsigned int size);
                inline void adoptCentroid(::capnp::Orphan< ::capnp::List<float>>&& value);
                inline ::capnp::Orphan< ::capnp::List<float>> disownCentroid();

                inline  ::uint32_t getUserData();
                inline void setUserData(::uint32_t value);

            private:
                ::capnp::_::StructBuilder _builder;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
                friend class ::capnp::Orphanage;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::_::PointerHelpers;
            };

#if !CAPNP_LITE
            class NvBlastBond::Pipeline {
            public:
                typedef NvBlastBond Pipelines;

                inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
                inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
                    : _typeless(kj::mv(typeless)) {}

            private:
                ::capnp::AnyPointer::Pipeline _typeless;
                friend class ::capnp::PipelineHook;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
            };
#endif  // !CAPNP_LITE

            class NvBlastSupportGraph::Reader {
            public:
                typedef NvBlastSupportGraph Reads;

                Reader() = default;
                inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

                inline ::capnp::MessageSize totalSize() const {
                    return _reader.totalSize().asPublic();
                }

#if !CAPNP_LITE
                inline ::kj::StringTree toString() const {
                    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
                }
#endif  // !CAPNP_LITE

                inline  ::uint32_t getNodeCount() const;

                inline bool hasChunkIndices() const;
                inline  ::capnp::List< ::uint32_t>::Reader getChunkIndices() const;

                inline bool hasAdjacencyPartition() const;
                inline  ::capnp::List< ::uint32_t>::Reader getAdjacencyPartition() const;

                inline bool hasAdjacentNodeIndices() const;
                inline  ::capnp::List< ::uint32_t>::Reader getAdjacentNodeIndices() const;

                inline bool hasAdjacentBondIndices() const;
                inline  ::capnp::List< ::uint32_t>::Reader getAdjacentBondIndices() const;

            private:
                ::capnp::_::StructReader _reader;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::_::PointerHelpers;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::List;
                friend class ::capnp::MessageBuilder;
                friend class ::capnp::Orphanage;
            };

            class NvBlastSupportGraph::Builder {
            public:
                typedef NvBlastSupportGraph Builds;

                Builder() = delete;  // Deleted to discourage incorrect usage.
                // You can explicitly initialize to nullptr instead.
                inline Builder(decltype(nullptr)) {}
                inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
                inline operator Reader() const { return Reader(_builder.asReader()); }
                inline Reader asReader() const { return *this; }

                inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
                inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

                inline  ::uint32_t getNodeCount();
                inline void setNodeCount(::uint32_t value);

                inline bool hasChunkIndices();
                inline  ::capnp::List< ::uint32_t>::Builder getChunkIndices();
                inline void setChunkIndices(::capnp::List< ::uint32_t>::Reader value);
                inline void setChunkIndices(::kj::ArrayPtr<const  ::uint32_t> value);
                inline  ::capnp::List< ::uint32_t>::Builder initChunkIndices(unsigned int size);
                inline void adoptChunkIndices(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
                inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownChunkIndices();

                inline bool hasAdjacencyPartition();
                inline  ::capnp::List< ::uint32_t>::Builder getAdjacencyPartition();
                inline void setAdjacencyPartition(::capnp::List< ::uint32_t>::Reader value);
                inline void setAdjacencyPartition(::kj::ArrayPtr<const  ::uint32_t> value);
                inline  ::capnp::List< ::uint32_t>::Builder initAdjacencyPartition(unsigned int size);
                inline void adoptAdjacencyPartition(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
                inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownAdjacencyPartition();

                inline bool hasAdjacentNodeIndices();
                inline  ::capnp::List< ::uint32_t>::Builder getAdjacentNodeIndices();
                inline void setAdjacentNodeIndices(::capnp::List< ::uint32_t>::Reader value);
                inline void setAdjacentNodeIndices(::kj::ArrayPtr<const  ::uint32_t> value);
                inline  ::capnp::List< ::uint32_t>::Builder initAdjacentNodeIndices(unsigned int size);
                inline void adoptAdjacentNodeIndices(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
                inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownAdjacentNodeIndices();

                inline bool hasAdjacentBondIndices();
                inline  ::capnp::List< ::uint32_t>::Builder getAdjacentBondIndices();
                inline void setAdjacentBondIndices(::capnp::List< ::uint32_t>::Reader value);
                inline void setAdjacentBondIndices(::kj::ArrayPtr<const  ::uint32_t> value);
                inline  ::capnp::List< ::uint32_t>::Builder initAdjacentBondIndices(unsigned int size);
                inline void adoptAdjacentBondIndices(::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value);
                inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> disownAdjacentBondIndices();

            private:
                ::capnp::_::StructBuilder _builder;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
                friend class ::capnp::Orphanage;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::_::PointerHelpers;
            };

#if !CAPNP_LITE
            class NvBlastSupportGraph::Pipeline {
            public:
                typedef NvBlastSupportGraph Pipelines;

                inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
                inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
                    : _typeless(kj::mv(typeless)) {}

            private:
                ::capnp::AnyPointer::Pipeline _typeless;
                friend class ::capnp::PipelineHook;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
            };
#endif  // !CAPNP_LITE

            class UUID::Reader {
            public:
                typedef UUID Reads;

                Reader() = default;
                inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

                inline ::capnp::MessageSize totalSize() const {
                    return _reader.totalSize().asPublic();
                }

#if !CAPNP_LITE
                inline ::kj::StringTree toString() const {
                    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
                }
#endif  // !CAPNP_LITE

                inline bool hasValue() const;
                inline  ::capnp::Data::Reader getValue() const;

            private:
                ::capnp::_::StructReader _reader;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::_::PointerHelpers;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::List;
                friend class ::capnp::MessageBuilder;
                friend class ::capnp::Orphanage;
            };

            class UUID::Builder {
            public:
                typedef UUID Builds;

                Builder() = delete;  // Deleted to discourage incorrect usage.
                // You can explicitly initialize to nullptr instead.
                inline Builder(decltype(nullptr)) {}
                inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
                inline operator Reader() const { return Reader(_builder.asReader()); }
                inline Reader asReader() const { return *this; }

                inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
                inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

                inline bool hasValue();
                inline  ::capnp::Data::Builder getValue();
                inline void setValue(::capnp::Data::Reader value);
                inline  ::capnp::Data::Builder initValue(unsigned int size);
                inline void adoptValue(::capnp::Orphan< ::capnp::Data>&& value);
                inline ::capnp::Orphan< ::capnp::Data> disownValue();

            private:
                ::capnp::_::StructBuilder _builder;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
                friend class ::capnp::Orphanage;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::_::PointerHelpers;
            };

#if !CAPNP_LITE
            class UUID::Pipeline {
            public:
                typedef UUID Pipelines;

                inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
                inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
                    : _typeless(kj::mv(typeless)) {}

            private:
                ::capnp::AnyPointer::Pipeline _typeless;
                friend class ::capnp::PipelineHook;
                template <typename, ::capnp::Kind>
                friend struct ::capnp::ToDynamic_;
            };
#endif  // !CAPNP_LITE

            // =======================================================================================

            inline bool Asset::Reader::hasHeader() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
            }
            inline bool Asset::Builder::hasHeader() {
                return !_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
            }
            inline  ::Nv::Blast::Serialization::NvBlastDataBlock::Reader Asset::Reader::getHeader() const {
                return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::NvBlastDataBlock>::get(_reader.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }
            inline  ::Nv::Blast::Serialization::NvBlastDataBlock::Builder Asset::Builder::getHeader() {
                return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::NvBlastDataBlock>::get(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }
#if !CAPNP_LITE
            inline  ::Nv::Blast::Serialization::NvBlastDataBlock::Pipeline Asset::Pipeline::getHeader() {
                return  ::Nv::Blast::Serialization::NvBlastDataBlock::Pipeline(_typeless.getPointerField(0));
            }
#endif  // !CAPNP_LITE
            inline void Asset::Builder::setHeader(::Nv::Blast::Serialization::NvBlastDataBlock::Reader value) {
                ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::NvBlastDataBlock>::set(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), value);
            }
            inline  ::Nv::Blast::Serialization::NvBlastDataBlock::Builder Asset::Builder::initHeader() {
                return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::NvBlastDataBlock>::init(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }
            inline void Asset::Builder::adoptHeader(
                ::capnp::Orphan< ::Nv::Blast::Serialization::NvBlastDataBlock>&& value) {
                ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::NvBlastDataBlock>::adopt(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::Nv::Blast::Serialization::NvBlastDataBlock> Asset::Builder::disownHeader() {
                return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::NvBlastDataBlock>::disown(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }

            inline bool Asset::Reader::hasID() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
            }
            inline bool Asset::Builder::hasID() {
                return !_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
            }
            inline  ::Nv::Blast::Serialization::UUID::Reader Asset::Reader::getID() const {
                return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::UUID>::get(_reader.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS));
            }
            inline  ::Nv::Blast::Serialization::UUID::Builder Asset::Builder::getID() {
                return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::UUID>::get(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS));
            }
#if !CAPNP_LITE
            inline  ::Nv::Blast::Serialization::UUID::Pipeline Asset::Pipeline::getID() {
                return  ::Nv::Blast::Serialization::UUID::Pipeline(_typeless.getPointerField(1));
            }
#endif  // !CAPNP_LITE
            inline void Asset::Builder::setID(::Nv::Blast::Serialization::UUID::Reader value) {
                ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::UUID>::set(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS), value);
            }
            inline  ::Nv::Blast::Serialization::UUID::Builder Asset::Builder::initID() {
                return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::UUID>::init(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS));
            }
            inline void Asset::Builder::adoptID(
                ::capnp::Orphan< ::Nv::Blast::Serialization::UUID>&& value) {
                ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::UUID>::adopt(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::Nv::Blast::Serialization::UUID> Asset::Builder::disownID() {
                return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::UUID>::disown(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS));
            }

            inline  ::uint32_t Asset::Reader::getChunkCount() const {
                return _reader.getDataField< ::uint32_t>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS);
            }

            inline  ::uint32_t Asset::Builder::getChunkCount() {
                return _builder.getDataField< ::uint32_t>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS);
            }
            inline void Asset::Builder::setChunkCount(::uint32_t value) {
                _builder.setDataField< ::uint32_t>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
            }

            inline bool Asset::Reader::hasGraph() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
            }
            inline bool Asset::Builder::hasGraph() {
                return !_builder.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
            }
            inline  ::Nv::Blast::Serialization::NvBlastSupportGraph::Reader Asset::Reader::getGraph() const {
                return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::NvBlastSupportGraph>::get(_reader.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS));
            }
            inline  ::Nv::Blast::Serialization::NvBlastSupportGraph::Builder Asset::Builder::getGraph() {
                return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::NvBlastSupportGraph>::get(_builder.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS));
            }
#if !CAPNP_LITE
            inline  ::Nv::Blast::Serialization::NvBlastSupportGraph::Pipeline Asset::Pipeline::getGraph() {
                return  ::Nv::Blast::Serialization::NvBlastSupportGraph::Pipeline(_typeless.getPointerField(2));
            }
#endif  // !CAPNP_LITE
            inline void Asset::Builder::setGraph(::Nv::Blast::Serialization::NvBlastSupportGraph::Reader value) {
                ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::NvBlastSupportGraph>::set(_builder.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS), value);
            }
            inline  ::Nv::Blast::Serialization::NvBlastSupportGraph::Builder Asset::Builder::initGraph() {
                return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::NvBlastSupportGraph>::init(_builder.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS));
            }
            inline void Asset::Builder::adoptGraph(
                ::capnp::Orphan< ::Nv::Blast::Serialization::NvBlastSupportGraph>&& value) {
                ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::NvBlastSupportGraph>::adopt(_builder.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::Nv::Blast::Serialization::NvBlastSupportGraph> Asset::Builder::disownGraph() {
                return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::NvBlastSupportGraph>::disown(_builder.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS));
            }

            inline  ::uint32_t Asset::Reader::getLeafChunkCount() const {
                return _reader.getDataField< ::uint32_t>(
                    ::capnp::bounded<1>() * ::capnp::ELEMENTS);
            }

            inline  ::uint32_t Asset::Builder::getLeafChunkCount() {
                return _builder.getDataField< ::uint32_t>(
                    ::capnp::bounded<1>() * ::capnp::ELEMENTS);
            }
            inline void Asset::Builder::setLeafChunkCount(::uint32_t value) {
                _builder.setDataField< ::uint32_t>(
                    ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
            }

            inline  ::uint32_t Asset::Reader::getFirstSubsupportChunkIndex() const {
                return _reader.getDataField< ::uint32_t>(
                    ::capnp::bounded<2>() * ::capnp::ELEMENTS);
            }

            inline  ::uint32_t Asset::Builder::getFirstSubsupportChunkIndex() {
                return _builder.getDataField< ::uint32_t>(
                    ::capnp::bounded<2>() * ::capnp::ELEMENTS);
            }
            inline void Asset::Builder::setFirstSubsupportChunkIndex(::uint32_t value) {
                _builder.setDataField< ::uint32_t>(
                    ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
            }

            inline  ::uint32_t Asset::Reader::getBondCount() const {
                return _reader.getDataField< ::uint32_t>(
                    ::capnp::bounded<3>() * ::capnp::ELEMENTS);
            }

            inline  ::uint32_t Asset::Builder::getBondCount() {
                return _builder.getDataField< ::uint32_t>(
                    ::capnp::bounded<3>() * ::capnp::ELEMENTS);
            }
            inline void Asset::Builder::setBondCount(::uint32_t value) {
                _builder.setDataField< ::uint32_t>(
                    ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
            }

            inline bool Asset::Reader::hasChunks() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
            }
            inline bool Asset::Builder::hasChunks() {
                return !_builder.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
            }
            inline  ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>::Reader Asset::Reader::getChunks() const {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>>::get(_reader.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS));
            }
            inline  ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>::Builder Asset::Builder::getChunks() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>>::get(_builder.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS));
            }
            inline void Asset::Builder::setChunks(::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>::Reader value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>>::set(_builder.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS), value);
            }
            inline  ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>::Builder Asset::Builder::initChunks(unsigned int size) {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>>::init(_builder.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS), size);
            }
            inline void Asset::Builder::adoptChunks(
                ::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>>&& value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>>::adopt(_builder.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>> Asset::Builder::disownChunks() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::NvBlastChunk>>::disown(_builder.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS));
            }

            inline bool Asset::Reader::hasBonds() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
            }
            inline bool Asset::Builder::hasBonds() {
                return !_builder.getPointerField(
                    ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
            }
            inline  ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>::Reader Asset::Reader::getBonds() const {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>>::get(_reader.getPointerField(
                    ::capnp::bounded<4>() * ::capnp::POINTERS));
            }
            inline  ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>::Builder Asset::Builder::getBonds() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>>::get(_builder.getPointerField(
                    ::capnp::bounded<4>() * ::capnp::POINTERS));
            }
            inline void Asset::Builder::setBonds(::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>::Reader value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>>::set(_builder.getPointerField(
                    ::capnp::bounded<4>() * ::capnp::POINTERS), value);
            }
            inline  ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>::Builder Asset::Builder::initBonds(unsigned int size) {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>>::init(_builder.getPointerField(
                    ::capnp::bounded<4>() * ::capnp::POINTERS), size);
            }
            inline void Asset::Builder::adoptBonds(
                ::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>>&& value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>>::adopt(_builder.getPointerField(
                    ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>> Asset::Builder::disownBonds() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::NvBlastBond>>::disown(_builder.getPointerField(
                    ::capnp::bounded<4>() * ::capnp::POINTERS));
            }

            inline bool Asset::Reader::hasSubtreeLeafChunkCounts() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
            }
            inline bool Asset::Builder::hasSubtreeLeafChunkCounts() {
                return !_builder.getPointerField(
                    ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
            }
            inline  ::capnp::List< ::uint32_t>::Reader Asset::Reader::getSubtreeLeafChunkCounts() const {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_reader.getPointerField(
                    ::capnp::bounded<5>() * ::capnp::POINTERS));
            }
            inline  ::capnp::List< ::uint32_t>::Builder Asset::Builder::getSubtreeLeafChunkCounts() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_builder.getPointerField(
                    ::capnp::bounded<5>() * ::capnp::POINTERS));
            }
            inline void Asset::Builder::setSubtreeLeafChunkCounts(::capnp::List< ::uint32_t>::Reader value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
                    ::capnp::bounded<5>() * ::capnp::POINTERS), value);
            }
            inline void Asset::Builder::setSubtreeLeafChunkCounts(::kj::ArrayPtr<const  ::uint32_t> value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
                    ::capnp::bounded<5>() * ::capnp::POINTERS), value);
            }
            inline  ::capnp::List< ::uint32_t>::Builder Asset::Builder::initSubtreeLeafChunkCounts(unsigned int size) {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(_builder.getPointerField(
                    ::capnp::bounded<5>() * ::capnp::POINTERS), size);
            }
            inline void Asset::Builder::adoptSubtreeLeafChunkCounts(
                ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(_builder.getPointerField(
                    ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> Asset::Builder::disownSubtreeLeafChunkCounts() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(_builder.getPointerField(
                    ::capnp::bounded<5>() * ::capnp::POINTERS));
            }

            inline bool Asset::Reader::hasChunkToGraphNodeMap() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
            }
            inline bool Asset::Builder::hasChunkToGraphNodeMap() {
                return !_builder.getPointerField(
                    ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
            }
            inline  ::capnp::List< ::uint32_t>::Reader Asset::Reader::getChunkToGraphNodeMap() const {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_reader.getPointerField(
                    ::capnp::bounded<6>() * ::capnp::POINTERS));
            }
            inline  ::capnp::List< ::uint32_t>::Builder Asset::Builder::getChunkToGraphNodeMap() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_builder.getPointerField(
                    ::capnp::bounded<6>() * ::capnp::POINTERS));
            }
            inline void Asset::Builder::setChunkToGraphNodeMap(::capnp::List< ::uint32_t>::Reader value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
                    ::capnp::bounded<6>() * ::capnp::POINTERS), value);
            }
            inline void Asset::Builder::setChunkToGraphNodeMap(::kj::ArrayPtr<const  ::uint32_t> value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
                    ::capnp::bounded<6>() * ::capnp::POINTERS), value);
            }
            inline  ::capnp::List< ::uint32_t>::Builder Asset::Builder::initChunkToGraphNodeMap(unsigned int size) {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(_builder.getPointerField(
                    ::capnp::bounded<6>() * ::capnp::POINTERS), size);
            }
            inline void Asset::Builder::adoptChunkToGraphNodeMap(
                ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(_builder.getPointerField(
                    ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> Asset::Builder::disownChunkToGraphNodeMap() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(_builder.getPointerField(
                    ::capnp::bounded<6>() * ::capnp::POINTERS));
            }

            inline  ::Nv::Blast::Serialization::NvBlastDataBlock::Type NvBlastDataBlock::Reader::getDataType() const {
                return _reader.getDataField< ::Nv::Blast::Serialization::NvBlastDataBlock::Type>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS);
            }

            inline  ::Nv::Blast::Serialization::NvBlastDataBlock::Type NvBlastDataBlock::Builder::getDataType() {
                return _builder.getDataField< ::Nv::Blast::Serialization::NvBlastDataBlock::Type>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS);
            }
            inline void NvBlastDataBlock::Builder::setDataType(::Nv::Blast::Serialization::NvBlastDataBlock::Type value) {
                _builder.setDataField< ::Nv::Blast::Serialization::NvBlastDataBlock::Type>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
            }

            inline  ::uint32_t NvBlastDataBlock::Reader::getFormatVersion() const {
                return _reader.getDataField< ::uint32_t>(
                    ::capnp::bounded<1>() * ::capnp::ELEMENTS);
            }

            inline  ::uint32_t NvBlastDataBlock::Builder::getFormatVersion() {
                return _builder.getDataField< ::uint32_t>(
                    ::capnp::bounded<1>() * ::capnp::ELEMENTS);
            }
            inline void NvBlastDataBlock::Builder::setFormatVersion(::uint32_t value) {
                _builder.setDataField< ::uint32_t>(
                    ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
            }

            inline  ::uint32_t NvBlastDataBlock::Reader::getSize() const {
                return _reader.getDataField< ::uint32_t>(
                    ::capnp::bounded<2>() * ::capnp::ELEMENTS);
            }

            inline  ::uint32_t NvBlastDataBlock::Builder::getSize() {
                return _builder.getDataField< ::uint32_t>(
                    ::capnp::bounded<2>() * ::capnp::ELEMENTS);
            }
            inline void NvBlastDataBlock::Builder::setSize(::uint32_t value) {
                _builder.setDataField< ::uint32_t>(
                    ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
            }

            inline bool NvBlastChunk::Reader::hasCentroid() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
            }
            inline bool NvBlastChunk::Builder::hasCentroid() {
                return !_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
            }
            inline  ::capnp::List<float>::Reader NvBlastChunk::Reader::getCentroid() const {
                return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_reader.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }
            inline  ::capnp::List<float>::Builder NvBlastChunk::Builder::getCentroid() {
                return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }
            inline void NvBlastChunk::Builder::setCentroid(::capnp::List<float>::Reader value) {
                ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), value);
            }
            inline void NvBlastChunk::Builder::setCentroid(::kj::ArrayPtr<const float> value) {
                ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), value);
            }
            inline  ::capnp::List<float>::Builder NvBlastChunk::Builder::initCentroid(unsigned int size) {
                return ::capnp::_::PointerHelpers< ::capnp::List<float>>::init(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), size);
            }
            inline void NvBlastChunk::Builder::adoptCentroid(
                ::capnp::Orphan< ::capnp::List<float>>&& value) {
                ::capnp::_::PointerHelpers< ::capnp::List<float>>::adopt(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::capnp::List<float>> NvBlastChunk::Builder::disownCentroid() {
                return ::capnp::_::PointerHelpers< ::capnp::List<float>>::disown(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }

            inline float NvBlastChunk::Reader::getVolume() const {
                return _reader.getDataField<float>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS);
            }

            inline float NvBlastChunk::Builder::getVolume() {
                return _builder.getDataField<float>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS);
            }
            inline void NvBlastChunk::Builder::setVolume(float value) {
                _builder.setDataField<float>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
            }

            inline  ::uint32_t NvBlastChunk::Reader::getParentChunkIndex() const {
                return _reader.getDataField< ::uint32_t>(
                    ::capnp::bounded<1>() * ::capnp::ELEMENTS);
            }

            inline  ::uint32_t NvBlastChunk::Builder::getParentChunkIndex() {
                return _builder.getDataField< ::uint32_t>(
                    ::capnp::bounded<1>() * ::capnp::ELEMENTS);
            }
            inline void NvBlastChunk::Builder::setParentChunkIndex(::uint32_t value) {
                _builder.setDataField< ::uint32_t>(
                    ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
            }

            inline  ::uint32_t NvBlastChunk::Reader::getFirstChildIndex() const {
                return _reader.getDataField< ::uint32_t>(
                    ::capnp::bounded<2>() * ::capnp::ELEMENTS);
            }

            inline  ::uint32_t NvBlastChunk::Builder::getFirstChildIndex() {
                return _builder.getDataField< ::uint32_t>(
                    ::capnp::bounded<2>() * ::capnp::ELEMENTS);
            }
            inline void NvBlastChunk::Builder::setFirstChildIndex(::uint32_t value) {
                _builder.setDataField< ::uint32_t>(
                    ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
            }

            inline  ::uint32_t NvBlastChunk::Reader::getChildIndexStop() const {
                return _reader.getDataField< ::uint32_t>(
                    ::capnp::bounded<3>() * ::capnp::ELEMENTS);
            }

            inline  ::uint32_t NvBlastChunk::Builder::getChildIndexStop() {
                return _builder.getDataField< ::uint32_t>(
                    ::capnp::bounded<3>() * ::capnp::ELEMENTS);
            }
            inline void NvBlastChunk::Builder::setChildIndexStop(::uint32_t value) {
                _builder.setDataField< ::uint32_t>(
                    ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
            }

            inline  ::uint32_t NvBlastChunk::Reader::getUserData() const {
                return _reader.getDataField< ::uint32_t>(
                    ::capnp::bounded<4>() * ::capnp::ELEMENTS);
            }

            inline  ::uint32_t NvBlastChunk::Builder::getUserData() {
                return _builder.getDataField< ::uint32_t>(
                    ::capnp::bounded<4>() * ::capnp::ELEMENTS);
            }
            inline void NvBlastChunk::Builder::setUserData(::uint32_t value) {
                _builder.setDataField< ::uint32_t>(
                    ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
            }

            inline bool NvBlastBond::Reader::hasNormal() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
            }
            inline bool NvBlastBond::Builder::hasNormal() {
                return !_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
            }
            inline  ::capnp::List<float>::Reader NvBlastBond::Reader::getNormal() const {
                return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_reader.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }
            inline  ::capnp::List<float>::Builder NvBlastBond::Builder::getNormal() {
                return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }
            inline void NvBlastBond::Builder::setNormal(::capnp::List<float>::Reader value) {
                ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), value);
            }
            inline void NvBlastBond::Builder::setNormal(::kj::ArrayPtr<const float> value) {
                ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), value);
            }
            inline  ::capnp::List<float>::Builder NvBlastBond::Builder::initNormal(unsigned int size) {
                return ::capnp::_::PointerHelpers< ::capnp::List<float>>::init(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), size);
            }
            inline void NvBlastBond::Builder::adoptNormal(
                ::capnp::Orphan< ::capnp::List<float>>&& value) {
                ::capnp::_::PointerHelpers< ::capnp::List<float>>::adopt(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::capnp::List<float>> NvBlastBond::Builder::disownNormal() {
                return ::capnp::_::PointerHelpers< ::capnp::List<float>>::disown(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }

            inline float NvBlastBond::Reader::getArea() const {
                return _reader.getDataField<float>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS);
            }

            inline float NvBlastBond::Builder::getArea() {
                return _builder.getDataField<float>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS);
            }
            inline void NvBlastBond::Builder::setArea(float value) {
                _builder.setDataField<float>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
            }

            inline bool NvBlastBond::Reader::hasCentroid() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
            }
            inline bool NvBlastBond::Builder::hasCentroid() {
                return !_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
            }
            inline  ::capnp::List<float>::Reader NvBlastBond::Reader::getCentroid() const {
                return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_reader.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS));
            }
            inline  ::capnp::List<float>::Builder NvBlastBond::Builder::getCentroid() {
                return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS));
            }
            inline void NvBlastBond::Builder::setCentroid(::capnp::List<float>::Reader value) {
                ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS), value);
            }
            inline void NvBlastBond::Builder::setCentroid(::kj::ArrayPtr<const float> value) {
                ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS), value);
            }
            inline  ::capnp::List<float>::Builder NvBlastBond::Builder::initCentroid(unsigned int size) {
                return ::capnp::_::PointerHelpers< ::capnp::List<float>>::init(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS), size);
            }
            inline void NvBlastBond::Builder::adoptCentroid(
                ::capnp::Orphan< ::capnp::List<float>>&& value) {
                ::capnp::_::PointerHelpers< ::capnp::List<float>>::adopt(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::capnp::List<float>> NvBlastBond::Builder::disownCentroid() {
                return ::capnp::_::PointerHelpers< ::capnp::List<float>>::disown(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS));
            }

            inline  ::uint32_t NvBlastBond::Reader::getUserData() const {
                return _reader.getDataField< ::uint32_t>(
                    ::capnp::bounded<1>() * ::capnp::ELEMENTS);
            }

            inline  ::uint32_t NvBlastBond::Builder::getUserData() {
                return _builder.getDataField< ::uint32_t>(
                    ::capnp::bounded<1>() * ::capnp::ELEMENTS);
            }
            inline void NvBlastBond::Builder::setUserData(::uint32_t value) {
                _builder.setDataField< ::uint32_t>(
                    ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
            }

            inline  ::uint32_t NvBlastSupportGraph::Reader::getNodeCount() const {
                return _reader.getDataField< ::uint32_t>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS);
            }

            inline  ::uint32_t NvBlastSupportGraph::Builder::getNodeCount() {
                return _builder.getDataField< ::uint32_t>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS);
            }
            inline void NvBlastSupportGraph::Builder::setNodeCount(::uint32_t value) {
                _builder.setDataField< ::uint32_t>(
                    ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
            }

            inline bool NvBlastSupportGraph::Reader::hasChunkIndices() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
            }
            inline bool NvBlastSupportGraph::Builder::hasChunkIndices() {
                return !_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
            }
            inline  ::capnp::List< ::uint32_t>::Reader NvBlastSupportGraph::Reader::getChunkIndices() const {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_reader.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }
            inline  ::capnp::List< ::uint32_t>::Builder NvBlastSupportGraph::Builder::getChunkIndices() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }
            inline void NvBlastSupportGraph::Builder::setChunkIndices(::capnp::List< ::uint32_t>::Reader value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), value);
            }
            inline void NvBlastSupportGraph::Builder::setChunkIndices(::kj::ArrayPtr<const  ::uint32_t> value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), value);
            }
            inline  ::capnp::List< ::uint32_t>::Builder NvBlastSupportGraph::Builder::initChunkIndices(unsigned int size) {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), size);
            }
            inline void NvBlastSupportGraph::Builder::adoptChunkIndices(
                ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> NvBlastSupportGraph::Builder::disownChunkIndices() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }

            inline bool NvBlastSupportGraph::Reader::hasAdjacencyPartition() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
            }
            inline bool NvBlastSupportGraph::Builder::hasAdjacencyPartition() {
                return !_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
            }
            inline  ::capnp::List< ::uint32_t>::Reader NvBlastSupportGraph::Reader::getAdjacencyPartition() const {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_reader.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS));
            }
            inline  ::capnp::List< ::uint32_t>::Builder NvBlastSupportGraph::Builder::getAdjacencyPartition() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS));
            }
            inline void NvBlastSupportGraph::Builder::setAdjacencyPartition(::capnp::List< ::uint32_t>::Reader value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS), value);
            }
            inline void NvBlastSupportGraph::Builder::setAdjacencyPartition(::kj::ArrayPtr<const  ::uint32_t> value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS), value);
            }
            inline  ::capnp::List< ::uint32_t>::Builder NvBlastSupportGraph::Builder::initAdjacencyPartition(unsigned int size) {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS), size);
            }
            inline void NvBlastSupportGraph::Builder::adoptAdjacencyPartition(
                ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> NvBlastSupportGraph::Builder::disownAdjacencyPartition() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(_builder.getPointerField(
                    ::capnp::bounded<1>() * ::capnp::POINTERS));
            }

            inline bool NvBlastSupportGraph::Reader::hasAdjacentNodeIndices() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
            }
            inline bool NvBlastSupportGraph::Builder::hasAdjacentNodeIndices() {
                return !_builder.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
            }
            inline  ::capnp::List< ::uint32_t>::Reader NvBlastSupportGraph::Reader::getAdjacentNodeIndices() const {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_reader.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS));
            }
            inline  ::capnp::List< ::uint32_t>::Builder NvBlastSupportGraph::Builder::getAdjacentNodeIndices() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_builder.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS));
            }
            inline void NvBlastSupportGraph::Builder::setAdjacentNodeIndices(::capnp::List< ::uint32_t>::Reader value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS), value);
            }
            inline void NvBlastSupportGraph::Builder::setAdjacentNodeIndices(::kj::ArrayPtr<const  ::uint32_t> value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS), value);
            }
            inline  ::capnp::List< ::uint32_t>::Builder NvBlastSupportGraph::Builder::initAdjacentNodeIndices(unsigned int size) {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(_builder.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS), size);
            }
            inline void NvBlastSupportGraph::Builder::adoptAdjacentNodeIndices(
                ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(_builder.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> NvBlastSupportGraph::Builder::disownAdjacentNodeIndices() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(_builder.getPointerField(
                    ::capnp::bounded<2>() * ::capnp::POINTERS));
            }

            inline bool NvBlastSupportGraph::Reader::hasAdjacentBondIndices() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
            }
            inline bool NvBlastSupportGraph::Builder::hasAdjacentBondIndices() {
                return !_builder.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
            }
            inline  ::capnp::List< ::uint32_t>::Reader NvBlastSupportGraph::Reader::getAdjacentBondIndices() const {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_reader.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS));
            }
            inline  ::capnp::List< ::uint32_t>::Builder NvBlastSupportGraph::Builder::getAdjacentBondIndices() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::get(_builder.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS));
            }
            inline void NvBlastSupportGraph::Builder::setAdjacentBondIndices(::capnp::List< ::uint32_t>::Reader value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS), value);
            }
            inline void NvBlastSupportGraph::Builder::setAdjacentBondIndices(::kj::ArrayPtr<const  ::uint32_t> value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::set(_builder.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS), value);
            }
            inline  ::capnp::List< ::uint32_t>::Builder NvBlastSupportGraph::Builder::initAdjacentBondIndices(unsigned int size) {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::init(_builder.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS), size);
            }
            inline void NvBlastSupportGraph::Builder::adoptAdjacentBondIndices(
                ::capnp::Orphan< ::capnp::List< ::uint32_t>>&& value) {
                ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::adopt(_builder.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::capnp::List< ::uint32_t>> NvBlastSupportGraph::Builder::disownAdjacentBondIndices() {
                return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t>>::disown(_builder.getPointerField(
                    ::capnp::bounded<3>() * ::capnp::POINTERS));
            }

            inline bool UUID::Reader::hasValue() const {
                return !_reader.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
            }
            inline bool UUID::Builder::hasValue() {
                return !_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
            }
            inline  ::capnp::Data::Reader UUID::Reader::getValue() const {
                return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }
            inline  ::capnp::Data::Builder UUID::Builder::getValue() {
                return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }
            inline void UUID::Builder::setValue(::capnp::Data::Reader value) {
                ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), value);
            }
            inline  ::capnp::Data::Builder UUID::Builder::initValue(unsigned int size) {
                return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), size);
            }
            inline void UUID::Builder::adoptValue(
                ::capnp::Orphan< ::capnp::Data>&& value) {
                ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
            }
            inline ::capnp::Orphan< ::capnp::Data> UUID::Builder::disownValue() {
                return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
                    ::capnp::bounded<0>() * ::capnp::POINTERS));
            }

        }  // namespace
    }  // namespace
}  // namespace

#endif  // CAPNP_INCLUDED_9a4a58fac38375e0_